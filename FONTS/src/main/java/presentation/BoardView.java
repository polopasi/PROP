/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package presentation;

import java.util.TreeSet;
import java.util.ArrayList;
import java.util.Date;

import domain.Board;
import domain.BoardGenerator;
import domain.Cell;
import domain.Game;
import domain.Partition;
import domain.operations.Operations;
import helpers.InOut;

/**
 *
 * @author Liam Garriga
 */
public class BoardView extends javax.swing.JPanel {

    ViewController viewController;
    boolean edit;
    String player;
    Game game;

    /**
     * Creates new form BoardView
     */
    public BoardView(ViewController viewController) {
        this.viewController = viewController;
        initComponents();
        this.setSize(1280, 720);
        this.setVisible(false);
    }

    public void init(boolean edit, String user, Game game) {
        this.edit = edit;
        this.player = user;
        this.game = game;
        this.Cells = new ArrayList<>();

        this.initializing = true;

        this.initGeneratorInterface();
        this.initPlayInterface();

        if (!edit) { 
            this.initBoard();
        }
        
        this.invalidate();
        this.revalidate();
        this.repaint();

        this.initializing = false;
        this.startTime = new Date();
    }
    
    private void initBoard() {
        this.Grid.removeAll();
        
        final var board = this.game.getBoard();
        final int size = board.getSize();
        final var cells = board.getCells();
        final var partitions = board.getPartitions();
        this.Grid.setLayout(new java.awt.GridLayout(size, size));

        final var seenPartitions = new java.util.TreeMap<Integer, TreeSet<Integer>>();
        for (int row = 0; row < size; row++) {
            for (int col = 0; col < size; col++) {
                final var c = cells.get(row * size + col);
                final var p = c.getPartition();
                final var cellpanel = mkCell(
                    row,
                    col,
                    size,
                    cells,
                    partitions,
                    p == -1 || col < 1 || cells.get(row * size + (col - 1)).getPartition() != p,
                    p == -1 || col >= size - 1 || cells.get(row * size + (col + 1)).getPartition() != p,
                    p == -1 || row < 1 || cells.get((row - 1) * size + col).getPartition() != p,
                    p == -1 || row >= size - 1 || cells.get((row + 1) * size + col).getPartition() != p,
                    seenPartitions
                );
                this.Cells.add(cellpanel);
                this.Grid.add(cellpanel);
            }
        }
        for (final var entry : seenPartitions.entrySet()) {
            partitions.get(entry.getKey()).setSize(entry.getValue().size());
        }
        
        this.Grid.invalidate();
        this.Grid.revalidate();
        this.Grid.repaint();

        this.invalidate();
        this.revalidate();
        this.repaint();
    }
    
    private void clearBoard() {
        final int size = this.game.getBoard().getSize();
        final var cells = new ArrayList<Cell>(size);
        for (int i = 0; i < size * size; i++) cells.add(new Cell(0, -1));
        final var board = new Board(size, cells, new ArrayList<>());
        this.game.setBoard(board);

        this.initBoard();
    }
    
    private void initGeneratorInterface() {
        this.OperationsChecks.setVisible(edit);
        this.GenerateButtons.setVisible(edit);
        this.PartitionSize.setVisible(edit);
        
        if (edit) {
            this.minPartSize.setValue(1);
            this.maxPartSize.setValue(4);
            this.mergeProb.setValue(50);
            
            if (this.game.getLevel() == -1) {
                this.boardSize.setValue(4);
                this.game.getBoard().setSize(4);
                this.clearBoard();
            } else {
                this.boardSize.setValue(this.game.getBoard().getSize());
                this.initBoard();
            }
        }
    }
    
    private void initPlayInterface() {
        this.SaveLevel.setText(edit ? "Save Level" : "Save Game");
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        PlayButtons = new javax.swing.JPanel();
        CheckSolved = new javax.swing.JButton();
        CheckHasSolution = new javax.swing.JButton();
        GetCurrentSolution = new javax.swing.JButton();
        GetLevelSolution = new javax.swing.JButton();
        ExportLevel = new javax.swing.JButton();
        Separator = new javax.swing.JLabel();
        SaveLevel = new javax.swing.JButton();
        Grid = new javax.swing.JPanel();
        GenerateItems = new javax.swing.JPanel();
        OperationsChecks = new javax.swing.JPanel();
        OperationsLabel = new javax.swing.JLabel();
        AddCheck = new javax.swing.JCheckBox();
        SubCheck = new javax.swing.JCheckBox();
        MulCheck = new javax.swing.JCheckBox();
        DivCheck = new javax.swing.JCheckBox();
        ModCheck = new javax.swing.JCheckBox();
        PowCheck = new javax.swing.JCheckBox();
        PartitionSize = new javax.swing.JPanel();
        boardSizeLabel = new javax.swing.JLabel();
        boardSize = new javax.swing.JSpinner();
        minPartSizeLabel = new javax.swing.JLabel();
        minPartSize = new javax.swing.JSpinner();
        maxPartSizeLabel = new javax.swing.JLabel();
        maxPartSize = new javax.swing.JSpinner();
        mergeProbLabel = new javax.swing.JLabel();
        mergeProb = new javax.swing.JSpinner();
        GenerateButtons = new javax.swing.JPanel();
        Generate = new javax.swing.JButton();
        Generate1 = new javax.swing.JButton();
        ClearCells = new javax.swing.JButton();
        ClearBoard = new javax.swing.JButton();
        ExitButton = new javax.swing.JButton();

        setMaximumSize(new java.awt.Dimension(1280, 720));
        setMinimumSize(new java.awt.Dimension(1280, 720));
        setPreferredSize(new java.awt.Dimension(1280, 720));

        PlayButtons.setMinimumSize(new java.awt.Dimension(160, 145));
        PlayButtons.setPreferredSize(new java.awt.Dimension(180, 145));
        PlayButtons.setLayout(new java.awt.GridLayout(18, 1, 0, 5));

        CheckSolved.setText("Check if Solved");
        CheckSolved.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkSolvedClicked(evt);
            }
        });
        PlayButtons.add(CheckSolved);

        CheckHasSolution.setText("Check if Has Solution");
        CheckHasSolution.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkIfSolutionClicked(evt);
            }
        });
        PlayButtons.add(CheckHasSolution);

        GetCurrentSolution.setText("Get Current Solution");
        GetCurrentSolution.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getCurrentSolutionClicked(evt);
            }
        });
        PlayButtons.add(GetCurrentSolution);

        GetLevelSolution.setText("Get Level Solution");
        GetLevelSolution.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getLevelSolutionClicked(evt);
            }
        });
        PlayButtons.add(GetLevelSolution);

        ExportLevel.setText("Export Level");
        ExportLevel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExportLevelActionPerformed(evt);
            }
        });
        PlayButtons.add(ExportLevel);

        Separator.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        Separator.setText("------------------------");
        PlayButtons.add(Separator);

        SaveLevel.setText("Save Level");
        SaveLevel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SaveLevelActionPerformed(evt);
            }
        });
        PlayButtons.add(SaveLevel);

        Grid.setMaximumSize(new java.awt.Dimension(710, 710));
        Grid.setMinimumSize(new java.awt.Dimension(710, 710));
        Grid.setPreferredSize(new java.awt.Dimension(710, 710));
        Grid.setLayout(new java.awt.GridLayout(3, 3));

        GenerateItems.setMinimumSize(new java.awt.Dimension(360, 0));
        GenerateItems.setPreferredSize(new java.awt.Dimension(360, 293));

        OperationsChecks.setLayout(new java.awt.GridLayout(7, 0));

        OperationsLabel.setFont(new java.awt.Font("Cantarell", 0, 15)); // NOI18N
        OperationsLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        OperationsLabel.setText("Operations");
        OperationsChecks.add(OperationsLabel);

        AddCheck.setSelected(true);
        AddCheck.setText("Addition ( + )");
        OperationsChecks.add(AddCheck);

        SubCheck.setSelected(true);
        SubCheck.setText("Subtraction ( - )");
        OperationsChecks.add(SubCheck);

        MulCheck.setSelected(true);
        MulCheck.setText("Product ( * )");
        OperationsChecks.add(MulCheck);

        DivCheck.setSelected(true);
        DivCheck.setText("Division ( / )");
        OperationsChecks.add(DivCheck);

        ModCheck.setSelected(true);
        ModCheck.setText("Modulus ( % )");
        OperationsChecks.add(ModCheck);

        PowCheck.setSelected(true);
        PowCheck.setText("Power ( ^ )");
        OperationsChecks.add(PowCheck);

        PartitionSize.setLayout(new java.awt.GridLayout(4, 2));

        boardSizeLabel.setText("Board Size");
        PartitionSize.add(boardSizeLabel);

        boardSize.setName(""); // NOI18N
        boardSize.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                boardSizeStateChanged(evt);
            }
        });
        PartitionSize.add(boardSize);

        minPartSizeLabel.setText("Min Partition Size");
        PartitionSize.add(minPartSizeLabel);

        minPartSize.setName(""); // NOI18N
        minPartSize.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                minPartSizeStateChanged(evt);
            }
        });
        PartitionSize.add(minPartSize);

        maxPartSizeLabel.setText("Max Partition Size");
        PartitionSize.add(maxPartSizeLabel);

        maxPartSize.setName(""); // NOI18N
        maxPartSize.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                maxPartSizeStateChanged(evt);
            }
        });
        PartitionSize.add(maxPartSize);

        mergeProbLabel.setText("Merge Probability");
        PartitionSize.add(mergeProbLabel);

        mergeProb.setName(""); // NOI18N
        mergeProb.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                mergeProbStateChanged(evt);
            }
        });
        PartitionSize.add(mergeProb);

        Generate.setBackground(new java.awt.Color(255, 153, 51));
        Generate.setText("Generate new Level (Destructive)");
        Generate.setPreferredSize(new java.awt.Dimension(160, 25));
        Generate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GenerateNewPerformed(evt);
            }
        });

        Generate1.setText("Generate with Current as Base");
        Generate1.setPreferredSize(new java.awt.Dimension(160, 25));
        Generate1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                GenerateCurrentPerformed(evt);
            }
        });

        ClearCells.setBackground(new java.awt.Color(255, 102, 102));
        ClearCells.setText("Clear Cells");
        ClearCells.setPreferredSize(new java.awt.Dimension(160, 25));
        ClearCells.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearCellsPerformed(evt);
            }
        });

        ClearBoard.setBackground(new java.awt.Color(255, 102, 102));
        ClearBoard.setText("Remove all Partitions");
        ClearBoard.setPreferredSize(new java.awt.Dimension(160, 25));
        ClearBoard.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearBoardPerformed(evt);
            }
        });

        javax.swing.GroupLayout GenerateButtonsLayout = new javax.swing.GroupLayout(GenerateButtons);
        GenerateButtons.setLayout(GenerateButtonsLayout);
        GenerateButtonsLayout.setHorizontalGroup(
            GenerateButtonsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(GenerateButtonsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(GenerateButtonsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ClearCells, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(ClearBoard, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Generate1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(Generate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        GenerateButtonsLayout.setVerticalGroup(
            GenerateButtonsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(GenerateButtonsLayout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(Generate1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addComponent(Generate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ClearCells, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ClearBoard, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        javax.swing.GroupLayout GenerateItemsLayout = new javax.swing.GroupLayout(GenerateItems);
        GenerateItems.setLayout(GenerateItemsLayout);
        GenerateItemsLayout.setHorizontalGroup(
            GenerateItemsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(GenerateItemsLayout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addGroup(GenerateItemsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(OperationsChecks, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(GenerateItemsLayout.createSequentialGroup()
                        .addComponent(PartitionSize, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())))
            .addGroup(GenerateItemsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(GenerateButtons, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        GenerateItemsLayout.setVerticalGroup(
            GenerateItemsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(GenerateItemsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(PartitionSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(OperationsChecks, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(GenerateButtons, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(23, Short.MAX_VALUE))
        );

        ExitButton.setText("Exit");
        ExitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExitButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(GenerateItems, javax.swing.GroupLayout.PREFERRED_SIZE, 315, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(4, 4, 4)
                .addComponent(Grid, javax.swing.GroupLayout.PREFERRED_SIZE, 757, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(PlayButtons, javax.swing.GroupLayout.DEFAULT_SIZE, 190, Short.MAX_VALUE)
                        .addGap(2, 2, 2))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(ExitButton)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ExitButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(PlayButtons, javax.swing.GroupLayout.PREFERRED_SIZE, 568, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(Grid, javax.swing.GroupLayout.PREFERRED_SIZE, 720, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(GenerateItems, javax.swing.GroupLayout.PREFERRED_SIZE, 454, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(198, 198, 198))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void getCurrentSolutionClicked(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getCurrentSolutionClicked
        final var solved = this.game.getBoard().asSolver().solve();
        if (solved.isEmpty()) {
            javax.swing.JOptionPane.showMessageDialog(this, "The current board has no solution, try changing your approach.", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
        } else {
            this.game.setBoard(solved.get());
            this.initBoard();
        }
    }//GEN-LAST:event_getCurrentSolutionClicked
    
    private void getLevelSolutionClicked(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getLevelSolutionClicked
        try {
            final var board = this.game.getBoard();
            board.getCells().stream().forEach(c -> c.clear());
            this.game.setBoard(board.asSolver().solve().get());
            this.initBoard();
        } catch (Exception e) {
            e.printStackTrace();
            javax.swing.JOptionPane.showMessageDialog(this, "The current board has no solution.", "Kenken", javax.swing.JOptionPane.ERROR_MESSAGE);
        }

    }//GEN-LAST:event_getLevelSolutionClicked

    private void checkIfSolutionClicked(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkIfSolutionClicked
        try {
            // try solving
            final var solver = this.game.getBoard().asSolver();
            solver.solve().get();
            if (!solver.isSolved() || !solver.isCorrect()) throw new Exception();
            
            javax.swing.JOptionPane.showMessageDialog(this, "The current board can be solved", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
        } catch (Exception e) {
            javax.swing.JOptionPane.showMessageDialog(this, "The current board has no solution, try changing your approach.", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
        }
    }//GEN-LAST:event_checkIfSolutionClicked

    private void checkSolvedClicked(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkSolvedClicked
        final var solver = this.game.getBoard().asSolver();
        
        final boolean solved = solver.isSolved() && solver.isCorrect();
        String solvedStr;
        if (this.edit && solved) {
            javax.swing.JOptionPane.showMessageDialog(this, "The KenKen is solved!", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
            return;
        }

        if (solved) {
            if (this.game.getLevel() >= 0) {
                this.saveGameTime();
                this.viewController.setAsCompleted(this.game, this.player);
            }
            solvedStr = "Congratulations, you solved the KenKen in " + this.game.getTime() + " seconds!\n";
            solvedStr += "Your score has been saved into the Level's rankings.\n\n";
            solvedStr += "You will now be returned to the Main Menu";
        } else {
            solvedStr = "The KenKen is not yet solved, keep trying!";
        }
        javax.swing.JOptionPane.showMessageDialog(this, solvedStr, "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
        if (solved) {
            this.viewController.returnToMainMenu(this.player);
        }
    }//GEN-LAST:event_checkSolvedClicked

    private void ExportLevelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExportLevelActionPerformed
        javax.swing.JFileChooser fileChooser = new javax.swing.JFileChooser();
        if (fileChooser.showSaveDialog(this) == javax.swing.JFileChooser.APPROVE_OPTION) {
            java.io.File file = fileChooser.getSelectedFile();
            InOut inout = new InOut();
            try {
                try (java.io.BufferedWriter out = new java.io.BufferedWriter(new java.io.FileWriter(file))) {
                    out.write(this.game.getBoard().toPropFormat());
                    out.flush();
                }
                javax.swing.JOptionPane.showMessageDialog(this, "The level has been exported successfully to " + file.getAbsolutePath(), "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
            } catch (Exception e) {
                inout.printErr(e);
                javax.swing.JOptionPane.showMessageDialog(this, e.getMessage(), "Kenken", javax.swing.JOptionPane.ERROR_MESSAGE);
            }
          }
    }//GEN-LAST:event_ExportLevelActionPerformed

    private void GenerateNewPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GenerateNewPerformed
        int boardSize = (int)this.boardSize.getValue();
        final var list = new ArrayList<domain.Cell>(boardSize * boardSize);
        for (int i = 0; i < boardSize * boardSize; i++) list.add(new domain.Cell());
        final var board = new Board(boardSize, list, new ArrayList<>());

        final var operationsToInclude = new ArrayList<Operations>();
        if (this.AddCheck.isSelected()) operationsToInclude.add(Operations.ADDITION);
        if (this.SubCheck.isSelected()) operationsToInclude.add(Operations.SUBTRACTION);
        if (this.MulCheck.isSelected()) operationsToInclude.add(Operations.PRODUCT);
        if (this.DivCheck.isSelected()) operationsToInclude.add(Operations.DIVISION);
        if (this.ModCheck.isSelected()) operationsToInclude.add(Operations.MODULUS);
        if (this.PowCheck.isSelected()) operationsToInclude.add(Operations.POWER);

        final var generated = new BoardGenerator(board).generateWithLimits(
            (int)this.minPartSize.getValue(), 
            (int)this.maxPartSize.getValue(),
            (int)this.mergeProb.getValue(),
            operationsToInclude
        );
        if (generated.isPresent()) {
            this.game.setBoard(generated.get());
            this.initBoard();
        } else {
            javax.swing.JOptionPane.showMessageDialog(this, "The board could not be generated.\nTry changing some parameters or generating again.", "Kenken", javax.swing.JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_GenerateNewPerformed

    private void GenerateCurrentPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_GenerateCurrentPerformed
        final var operationsToInclude = new ArrayList<Operations>();
        if (this.AddCheck.isSelected()) operationsToInclude.add(Operations.ADDITION);
        if (this.SubCheck.isSelected()) operationsToInclude.add(Operations.SUBTRACTION);
        if (this.MulCheck.isSelected()) operationsToInclude.add(Operations.PRODUCT);
        if (this.DivCheck.isSelected()) operationsToInclude.add(Operations.DIVISION);
        if (this.ModCheck.isSelected()) operationsToInclude.add(Operations.MODULUS);
        if (this.PowCheck.isSelected()) operationsToInclude.add(Operations.POWER);
        
        final var generated = new BoardGenerator(this.game.getBoard()).generateWithLimits(
            (int)this.minPartSize.getValue(), 
            (int)this.maxPartSize.getValue(),
            (int)this.mergeProb.getValue(),
            operationsToInclude
        );
        if (generated.isPresent()) {
            this.game.setBoard(generated.get());
            this.initBoard();
        } else {
            javax.swing.JOptionPane.showMessageDialog(this, "A Level cannot be generated with the current state as a base, some restrictions are incompatible.", "Kenken", javax.swing.JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_GenerateCurrentPerformed
            
    private void minPartSizeStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_minPartSizeStateChanged
        if (initializing) return;

        int value = (int) minPartSize.getValue();
        if (value <= 0) {
            value = 1;
        } else if (value >= this.game.getBoard().getCells().size()) {
            value = this.game.getBoard().getCells().size();
        }
        minPartSize.setValue(value);
        if ((int)maxPartSize.getValue() < value) {
            maxPartSize.setValue(value);
        }
    }//GEN-LAST:event_minPartSizeStateChanged

    private void maxPartSizeStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_maxPartSizeStateChanged
        if (initializing) return;

        int value = (int) this.maxPartSize.getValue();
        if (value <= 0) {
            value = 1;
        } else if (value >= this.game.getBoard().getCells().size()) {
            value = this.game.getBoard().getCells().size();
        }
        this.maxPartSize.setValue(value);
        if ((int)minPartSize.getValue() > value) {
            this.minPartSize.setValue(value);
        }
    }//GEN-LAST:event_maxPartSizeStateChanged

    private void mergeProbStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_mergeProbStateChanged
        if (initializing) return;

        int value = (int) this.mergeProb.getValue();
        if (value < 0) {
            value = 0;
        } else if (value > 100) {
            value = 100;
        }
        this.mergeProb.setValue(value);
    }//GEN-LAST:event_mergeProbStateChanged

    private void boardSizeStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_boardSizeStateChanged
        if (initializing) return;

        int value = (int) this.boardSize.getValue();
        if (value <= 0) {
            value = 1;
        } else if (value == 11) {
            javax.swing.JOptionPane.showMessageDialog(this, "Setting the Board size to more than 10 can be computationally expensive.", "Kenken", javax.swing.JOptionPane.WARNING_MESSAGE);
        }
        this.boardSize.setValue(value);
        this.game.getBoard().setSize(value);
        this.clearBoard();
    }//GEN-LAST:event_boardSizeStateChanged

    private void ClearBoardPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearBoardPerformed
        this.clearBoard();
    }//GEN-LAST:event_ClearBoardPerformed

    private void ExitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExitButtonActionPerformed
        this.viewController.returnToMainMenu(this.player);
    }//GEN-LAST:event_ExitButtonActionPerformed

    private void ClearCellsPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearCellsPerformed
        for (Cell c : this.game.getBoard().getCells()) {
            c.clear();
        }
        this.initBoard();
    }//GEN-LAST:event_ClearCellsPerformed

    private void SaveLevelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SaveLevelActionPerformed
        if (!this.edit) {
            // Play mode
            this.saveGameTime();
            this.viewController.saveGame(this.player, this.game);
            this.viewController.persistDatabase();
            javax.swing.JOptionPane.showMessageDialog(this, "The game has been saved successfully.", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
            return;
        }

        final var board = new Board(this.game.getBoard());
        try {
            // try solving
            final var solver = board.asSolver();
            if (!solver.solve().isPresent()) {
                throw new Exception("The board has no solution");
            }
            if (!solver.isCorrect()) { 
                throw new Exception("The board is not correct");
            }
            
            for (final var c : board.getCells()) {
                c.clear();
            }
            this.viewController.addLevelDatabase(board, player);
            this.viewController.persistDatabase();
            javax.swing.JOptionPane.showMessageDialog(this, "The level has been saved successfully.", "Kenken", javax.swing.JOptionPane.INFORMATION_MESSAGE);
        } catch (Exception e) {
            e.printStackTrace();
            javax.swing.JOptionPane.showMessageDialog(this, e.getMessage() + ", it cannot be saved.", "Kenken", javax.swing.JOptionPane.ERROR_MESSAGE);
        }
        
    }//GEN-LAST:event_SaveLevelActionPerformed

    private boolean bfsIsCellInPartition(int row, int col, int queryPartition, int boardSize, java.util.List<Cell> cells, TreeSet<Integer> partitionCells, boolean[] checkedCells) {
        if (queryPartition != cells.get(row * boardSize + col).getPartition()) {
            return false;
        }
        if (checkedCells[row * boardSize + col]) {
            return false;
        }

        checkedCells[row * boardSize + col] = true;

        int left = row * boardSize + col - 1;
        int right = row * boardSize + col + 1;
        int up = (row-1) * boardSize + col;
        int down = (row+1) * boardSize + col;

        if (partitionCells.contains(left) || partitionCells.contains(right) || partitionCells.contains(up) || partitionCells.contains(down)) {
            return true;
        }

        return col > 0 && bfsIsCellInPartition(row, col-1, queryPartition, boardSize, cells, partitionCells, checkedCells)
            || col < boardSize-1 && bfsIsCellInPartition(row, col+1, queryPartition, boardSize, cells, partitionCells, checkedCells)
            || row > 0 && bfsIsCellInPartition(row-1, col, queryPartition, boardSize, cells, partitionCells, checkedCells)
            || row < boardSize-1 && bfsIsCellInPartition(row+1, col, queryPartition, boardSize, cells, partitionCells, checkedCells);
    }
    
    private javax.swing.JPanel mkCell(
            int row,
            int col,
            int boardSize,
            java.util.List<Cell> cells,
            java.util.List<Partition> partitions,
            boolean leftBorder,
            boolean rightBorder,
            boolean topBorder,
            boolean bottomBorder,
            java.util.TreeMap<Integer, TreeSet<Integer>> seenPartitions) {
        final int WIDTH = 30;
        final int HEIGHT = 30;
        
        Cell cell = cells.get(row * boardSize + col);
        int partitionId = cell.getPartition();
        int cellValue = cell.getValue().orElse(0);
        
        final javax.swing.JPanel cellPanel = new javax.swing.JPanel();
        final javax.swing.JTextField partitionResOpTxt = new javax.swing.JTextField();
        final javax.swing.JComboBox<Integer> partitionIdBox = new javax.swing.JComboBox<>();
        final javax.swing.JTextField valueTxt = new javax.swing.JTextField();
        
        if (!seenPartitions.containsKey(partitionId) && partitionId != -1) {
            final var set = java.util.stream.Stream.of(row * boardSize + col)
                .collect(java.util.stream.Collectors.toCollection(() -> new TreeSet<>()));
            seenPartitions.put(partitionId, set);
        } else if (partitionId != -1) {
            var partitionCells = seenPartitions.get(partitionId);
            // If the partition contains any neighbour, it's connected
            if (bfsIsCellInPartition(row, col, partitionId, boardSize, cells, partitionCells, new boolean[cells.size()])
            ) {
                partitionCells.add(row * boardSize + col);
            } else if (!partitionCells.contains(row * boardSize + col)) {
                // If not, it's separated
                partitionId = partitions.size();
                cell.setPartition(partitionId);
                partitions.add(new Partition(1, -1, Operations.NoOp));
                final var set = java.util.stream.Stream.of(row * boardSize + col)
                    .collect(java.util.stream.Collectors.toCollection(() -> new TreeSet<>()));
                seenPartitions.put(partitionId, set);
            }
        }
        
        partitionResOpTxt.setFont(new java.awt.Font("Cantarell", 0, 9)); // NOI18N
        partitionResOpTxt.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        if (partitionId != -1 && seenPartitions.get(partitionId).size() == 1) {
            final Partition partition = partitions.get(partitionId);
            String operation = operationToString(partition.getOperations());
            partitionResOpTxt.setText(Integer.toString(partition.getResult()) + operation);

            if (edit) {
                partitionResOpTxt.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.GRAY, 1, false));
            }
            partitionResOpTxt.setEditable(this.edit);
            partitionResOpTxt.setFocusable(this.edit);
            
            partitionResOpTxt.addFocusListener(new java.awt.event.FocusAdapter() {
                public void focusLost(java.awt.event.FocusEvent evt) {
                    final var partitionText = partitionResOpTxt.getText();
                    
                    if (partitionText.isEmpty()) {
                        final var oldPartitionId = cell.getPartition();
                        if (oldPartitionId == -1) { 
                            return;
                        }
                        final var oldPartition = partitions.get(oldPartitionId);
                        oldPartition.setSize(oldPartition.getSize()-1);
                        cell.setValue(0);
                        cell.setPartition(-1);
                        initBoard();
                        return;
                    }
                    final Partition partition = partitions.get(cell.getPartition());
                    final var oldRes = partition.getResult();
                    final var oldOp = partition.getOperations();
                    final Object[] newResOp = stringToResultOperation(partitionText);
                    if (newResOp.length == 2) {
                        partition.setResult((int)newResOp[0]);
                        partition.setOperations((Operations)newResOp[1]);
                    } else {
                        partitionResOpTxt.setText(Integer.toString(oldRes) + operationToString(oldOp));
                    }
                }
            });
        } else {
            partitionResOpTxt.setEditable(false);
            partitionResOpTxt.setFocusable(false);
        }
        
        if (edit) {
            partitionIdBox.setFont(new java.awt.Font("Cantarell", 0, 9)); // NOI18N
            partitionIdBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
            
            final java.util.function.Consumer<Integer> addItem = (item) -> {
                for (int i = 0; i < partitionIdBox.getItemCount(); i++) {
                    if (partitionIdBox.getItemAt(i) == item) return;
                }
                partitionIdBox.addItem(item);
            };
            addItem.accept(cell.getPartition());
            
            if (leftBorder && col > 0) addItem.accept(cells.get((row * boardSize + col - 1)).getPartition());
            if (rightBorder && col < boardSize-1) addItem.accept(cells.get((row * boardSize + col + 1)).getPartition());
            if (topBorder && row > 0) addItem.accept(cells.get(((row-1) * boardSize + col)).getPartition());
            if (bottomBorder && row < boardSize-1) addItem.accept(cells.get(((row+1) * boardSize + col)).getPartition());
            addItem.accept(-1);
            addItem.accept(partitions.size());
            
            partitionIdBox.setSelectedItem(cell.getPartition());
            
            partitionIdBox.addItemListener(new java.awt.event.ItemListener() {
                public void itemStateChanged(java.awt.event.ItemEvent evt) {
                    if (initializing) return;
                    final int selected = (int)partitionIdBox.getSelectedItem();
                    if (selected == partitions.size()) {
                        partitions.add(new Partition(1, 0, Operations.NoOp));
                    }
                    final int oldPartitionId = cell.getPartition();
                    if (oldPartitionId != -1) {
                        final var oldPartition = partitions.get(oldPartitionId);
                        oldPartition.setSize(oldPartition.getSize() - 1);
                    }
                    cell.setPartition(selected);
                    initBoard();
                }
            });
        }
        partitionIdBox.setVisible(edit);

        valueTxt.setBorder(javax.swing.BorderFactory.createLineBorder(java.awt.Color.GRAY, 1, false));
        valueTxt.setFont(new java.awt.Font("Cantarell", 0, 24)); // NOI18N
        valueTxt.setToolTipText("Cell Value");
        valueTxt.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        if (cellValue > 0) {
            valueTxt.setText(Integer.toString(cellValue));
        }
        valueTxt.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                final var board = game.getBoard();
                int oldValue = board.getValue(row+1, col+1).orElse(0);
                try {
                    var text = valueTxt.getText();
                    if (!board.setValue(row+1, col+1, text.isEmpty() ? 0 : Integer.parseInt(valueTxt.getText()))) {
                        throw new Exception();
                    }
                } catch (Exception e) {
                    valueTxt.setText(oldValue == 0 ? "" : Integer.toString(oldValue));
                }
            }
        });

        cellPanel.setBackground(java.awt.Color.white);
        cellPanel.setBorder(
                javax.swing.BorderFactory.createCompoundBorder(
                    javax.swing.BorderFactory.createMatteBorder(
                        topBorder ? 1 : 0,
                        leftBorder ? 1 : 0,
                        bottomBorder ? 1 : 0,
                        rightBorder ? 1 : 0,
                        java.awt.Color.BLACK
                    ),
                    javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0xeeeeee)))
        
        );
        cellPanel.setMaximumSize(new java.awt.Dimension(80, 80));
        cellPanel.setPreferredSize(new java.awt.Dimension(80, 80));

        javax.swing.GroupLayout cellLayout = new javax.swing.GroupLayout(cellPanel);
        cellPanel.setLayout(cellLayout);
        cellLayout.setHorizontalGroup(
            cellLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(cellLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(partitionResOpTxt))
                .addComponent(partitionIdBox)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, cellLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(valueTxt, javax.swing.GroupLayout.PREFERRED_SIZE, WIDTH, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        cellLayout.setVerticalGroup(
            cellLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, cellLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(partitionResOpTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addComponent(partitionIdBox)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 85, Short.MAX_VALUE)
                .addComponent(valueTxt, javax.swing.GroupLayout.PREFERRED_SIZE, HEIGHT, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(97, Short.MAX_VALUE))
        );

        return cellPanel;
    }

    private String operationToString(Operations operation) {
        switch (operation) {
            case ADDITION:
                return "+";
            case DIVISION:
                return "/";
            case MODULUS:
                return "%";
            case POWER:
                return "^";
            case PRODUCT:
                return "*";
            case SUBTRACTION:
                return "-";
            case NoOp:
            default:
                return "";
        }
    }

    private Operations stringToOperation(String string) {
        switch (string) {
            case "+":
                return Operations.ADDITION;
            case "/":
                return Operations.DIVISION;
            case "%":
                return Operations.MODULUS;
            case "^":
                return Operations.POWER;
            case "*":
                return Operations.PRODUCT;
            case "-":
                return Operations.SUBTRACTION;
            case "":
            default:
                return Operations.NoOp;
        }
    }
    
    /** Converts a string to an Operation/Result pair.<p>If the parsing fails, returns an empty array. */
    private Object[] stringToResultOperation(String string) {
        try {
            final var regex = java.util.regex.Pattern.compile("(\\d+)((\\+|\\/|\\%|\\^|\\*|\\-)?)");
            final var matcher = regex.matcher(string);
            if (!matcher.find()) {
                throw new Exception("Wrong partition string '" + string + "'");
            }
            String resString = matcher.group(1);
            String opString = matcher.group(2);
            return new Object[] { Integer.parseInt(resString), stringToOperation(opString) };
        } catch (Exception e) {
            e.printStackTrace();
            return new Object[] {};
        }
    }

    private void saveGameTime() {
        final long elapsed = (new Date().getTime() - this.startTime.getTime())/1000;
        this.game.setTime(this.game.getTime() + (int)elapsed);
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox AddCheck;
    private javax.swing.JButton CheckHasSolution;
    private javax.swing.JButton CheckSolved;
    private javax.swing.JButton ClearBoard;
    private javax.swing.JButton ClearCells;
    private javax.swing.JCheckBox DivCheck;
    private javax.swing.JButton ExitButton;
    private javax.swing.JButton ExportLevel;
    private javax.swing.JButton Generate;
    private javax.swing.JButton Generate1;
    private javax.swing.JPanel GenerateButtons;
    private javax.swing.JPanel GenerateItems;
    private javax.swing.JButton GetCurrentSolution;
    private javax.swing.JButton GetLevelSolution;
    private javax.swing.JPanel Grid;
    private javax.swing.JCheckBox ModCheck;
    private javax.swing.JCheckBox MulCheck;
    private javax.swing.JPanel OperationsChecks;
    private javax.swing.JLabel OperationsLabel;
    private javax.swing.JPanel PartitionSize;
    private javax.swing.JPanel PlayButtons;
    private javax.swing.JCheckBox PowCheck;
    private javax.swing.JButton SaveLevel;
    private javax.swing.JLabel Separator;
    private javax.swing.JCheckBox SubCheck;
    private javax.swing.JSpinner boardSize;
    private javax.swing.JLabel boardSizeLabel;
    private javax.swing.JSpinner maxPartSize;
    private javax.swing.JLabel maxPartSizeLabel;
    private javax.swing.JSpinner mergeProb;
    private javax.swing.JLabel mergeProbLabel;
    private javax.swing.JSpinner minPartSize;
    private javax.swing.JLabel minPartSizeLabel;
    // End of variables declaration//GEN-END:variables
    private ArrayList<javax.swing.JPanel> Cells;
    private boolean initializing;
    private java.util.Date startTime;
}